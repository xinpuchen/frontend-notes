(window.webpackJsonp=window.webpackJsonp||[]).push([[111],{543:function(t,r,e){"use strict";e.r(r);var a=e(55),o=Object(a.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"react-router-history-详解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-router-history-详解"}},[t._v("#")]),t._v(" React-Router-History 详解")]),t._v(" "),e("p",[t._v("在 react-router 4.0 版本中，API 与先前版本相比有了很大的修改，在 2.0、3.0 中常用的"),e("Router",[t._v("组件作为路由底层配置组件不再常用，取而代之的是四个各有不同的路由组件：")])],1),t._v(" "),e("blockquote",[e("p",[t._v("BrowserRouter>, HashRouter>, MemoryRouter>, StaticRouter>")])]),t._v(" "),e("h2",{attrs:{id:"memoryrouter"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#memoryrouter"}},[t._v("#")]),t._v(" MemoryRouter>")]),t._v(" "),e("p",[t._v("组件在内存中保存“URL”信息，不会修改浏览器的地址栏，往往用于 React Native 或测试环境等非浏览器环境")]),t._v(" "),e("h2",{attrs:{id:"staticrouter"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#staticrouter"}},[t._v("#")]),t._v(" StaticRouter>")]),t._v(" "),e("p",[t._v("组件从名字能看出它从不修改路由，这在服务器端渲染时很有用")]),t._v(" "),e("h2",{attrs:{id:"browserrouter-与-hashrouter"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#browserrouter-与-hashrouter"}},[t._v("#")]),t._v(" BrowserRouter> 与 HashRouter>")]),t._v(" "),e("p",[t._v("前者：http://127.0.0.1:3000/article/num1")]),t._v(" "),e("p",[t._v("后者：http://127.0.0.1:3000/#/article/num1 （不一定是这样，但#是少不了的）")]),t._v(" "),e("p",[t._v("这样的区别带来的直接问题就是，如果我们处于二级或者多级路由状态时，刷新页面，BrowserRouer 会将当前路由发送到服务器，而 HashRouter 不会（#hash 段）")])])}),[],!1,null,null,null);r.default=o.exports}}]);