(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{527:function(e,t,r){"use strict";r.r(t);var a=r(55),v=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"tree-sharking-详解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tree-sharking-详解"}},[e._v("#")]),e._v(" tree-sharking 详解")]),e._v(" "),r("h2",{attrs:{id:"原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[e._v("#")]),e._v(" 原理")]),e._v(" "),r("p",[e._v("tree-shaking 的消除原理是依赖于 ES6 的模块特性")]),e._v(" "),r("ul",[r("li",[e._v("只能作为模块顶层的语句出现")]),e._v(" "),r("li",[e._v("import 的模块名只能是字符串常量")]),e._v(" "),r("li",[e._v("import binding 是 immutable 的")])]),e._v(" "),r("p",[e._v("ES6 模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，然后进行消除，这就是 tree-shaking 的基础。")]),e._v(" "),r("p",[e._v("所谓静态分析就是不执行代码，从字面量上对代码进行分析，ES6 之前的模块化，比如我们可以动态 require 一个模块，只有执行后才知道引用的什么模块，这个就不能通过静态分析去做优化。")]),e._v(" "),r("p",[e._v("这是 ES6 modules 在设计时的一个重要考量，也是为什么没有直接采用 CommonJS，正是基于这个基础上，才使得 tree-shaking 成为可能，这也是为什么 rollup 和 webpack 2 都要用 ES6 module syntax 才能 tree-shaking。")]),e._v(" "),r("p",[e._v("而 tree-sharking 失败的原因是副作用，什么是副作用？")]),e._v(" "),r("h2",{attrs:{id:"副作用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#副作用"}},[e._v("#")]),e._v(" 副作用")]),e._v(" "),r("p",[e._v("副作用大致可以理解为一个函数会、或者可能会对函数外部变量产生影响的行为")]),e._v(" "),r("ul",[r("li",[e._v("函数的参数若是引用类型，对于它属性的操作，都是有可能会产生副作用的。因为首先它是引用类型，对它属性的任何修改其实都是改变了函数外部的数据。其次获取或修改它的属性，会触发 getter 或者 setter，而 getter、setter 是不透明的，有可能会产生副作用")]),e._v(" "),r("li",[e._v("uglify 没有完善的程序流分析。它可以简单的判断变量后续是否被引用、修改，但是不能判断一个变量完整的修改过程，不知道它是否已经指向了外部变量，所以很多有可能会产生副作用的代码，都只能保守的不删除")]),e._v(" "),r("li",[e._v("rollup 有程序流分析的功能，可以更好的判断代码是否真正会产生副作用")])]),e._v(" "),r("h2",{attrs:{id:"使用-rollup-打包-javascript-库"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#使用-rollup-打包-javascript-库"}},[e._v("#")]),e._v(" 使用 rollup 打包 JavaScript 库")]),e._v(" "),r("p",[e._v("打包工具库、组件库，还是 rollup 好用，因为：")]),e._v(" "),r("ol",[r("li",[e._v("它支持导出 ES 模块的包")]),e._v(" "),r("li",[e._v("它支持程序流分析，能更加正确的判断项目本身的代码是否有副作用")])]),e._v(" "),r("p",[e._v("只要通过 rollup 打出两份文件，一份 umd 版，一份 ES 模块版，它们的路径分别设为 "),r("code",[e._v("main")]),e._v("，"),r("code",[e._v("module")]),e._v(" 的值。这样就能方便使用者进行 tree-shaking。")]),e._v(" "),r("h2",{attrs:{id:"使用-webpack-打包工程化项目"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#使用-webpack-打包工程化项目"}},[e._v("#")]),e._v(" 使用 webpack 打包工程化项目")]),e._v(" "),r("p",[e._v("先进行 tree-shaking，再进行编译，减少编译带来的副作用，从而增加 tree-shaking 的效果")]),e._v(" "),r("h2",{attrs:{id:"总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),r("p",[e._v("在当下阶段，在 tree-shaking 上能够尽力的事：")]),e._v(" "),r("ol",[r("li",[e._v("尽量不写带有副作用的代码。诸如编写了立即执行函数，在函数里又使用了外部变量等")]),e._v(" "),r("li",[e._v("如果对 ES6 语义特性要求不是特别严格，可以开启 babel 的 "),r("code",[e._v("loose")]),e._v(" 模式，这个要根据自身项目判断，如：是否真的要不可枚举 class 的属性")]),e._v(" "),r("li",[e._v("如果是开发 JavaScript 库，请使用 rollup。并且提供 ES6 module 的版本，入口文件地址设置到 "),r("code",[e._v("package.json")]),e._v(" 的 "),r("code",[e._v("module")]),e._v(" 字段")]),e._v(" "),r("li",[e._v("如果 JavaScript 库开发中，难以避免的产生各种副作用代码，可以将功能函数或者组件，打包成单独的文件或目录，以便于用户可以通过目录去加载。如有条件，也可为自己的库开发单独的 webpack-loader，便于用户按需加载")]),e._v(" "),r("li",[e._v("如果是工程项目开发，对于依赖的组件，只能看组件提供者是否有对应上述 3、4 点的优化。对于自身的代码，除 1、2 两点外，对于项目有极致要求的话，可以先进行打包，最终再进行编译")]),e._v(" "),r("li",[e._v("如果对项目非常有把握，可以通过 "),r("code",[e._v("uglify")]),e._v(" 的一些编译配置，如：pure_getters: true，删除一些强制认为不会产生副作用的代码")])]),e._v(" "),r("h2",{attrs:{id:"参考文章"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[e._v("#")]),e._v(" 参考文章")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://juejin.im/post/6844903549290151949#heading-8",target:"_blank",rel:"noopener noreferrer"}},[e._v("你的 Tree-Shaking 并没什么卵用"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://juejin.im/post/6844903544756109319",target:"_blank",rel:"noopener noreferrer"}},[e._v("Tree-Shaking 性能优化实践 - 原理篇"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=v.exports}}]);