(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{520:function(t,s,e){"use strict";e.r(s);var a=e(55),r=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"node-定时器详解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node-定时器详解"}},[t._v("#")]),t._v(" Node 定时器详解")]),t._v(" "),e("p",[t._v("为了协调异步任务，Node 提供了四个定时器，让任务可以在指定的时间运行。")]),t._v(" "),e("ul",[e("li",[t._v("setTimeout()")]),t._v(" "),e("li",[t._v("setInterval()")]),t._v(" "),e("li",[t._v("setImmediate()")]),t._v(" "),e("li",[t._v("process.nextTick()")])]),t._v(" "),e("blockquote",[e("p",[t._v("前两个是语言的标准，后两个是 Node 独有的")])]),t._v(" "),e("h2",{attrs:{id:"同步任务和异步任务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#同步任务和异步任务"}},[t._v("#")]),t._v(" 同步任务和异步任务")]),t._v(" "),e("p",[t._v("首先，同步任务总是比异步任务更早执行。")]),t._v(" "),e("h2",{attrs:{id:"本轮循环和次轮循环"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#本轮循环和次轮循环"}},[t._v("#")]),t._v(" 本轮循环和次轮循环")]),t._v(" "),e("p",[t._v("异步任务可以分成两种")]),t._v(" "),e("ul",[e("li",[t._v("追加在本轮循环的异步任务")]),t._v(" "),e("li",[t._v("追加在次轮循环的异步任务")])]),t._v(" "),e("p",[t._v('所谓"循环"，指的是事件循环（event loop）。这是 JavaScript 引擎处理异步任务的方式，本轮循环一定早于次轮循环执行即可。')]),t._v(" "),e("p",[t._v("Node 规定，process.nextTick 和 Promise 的回调函数，追加在本轮循环，即同步任务一旦执行完成，就开始执行它们。而 setTimeout、setInterval、setImmediate 的回调函数，追加在次轮循环。")]),t._v(" "),e("h2",{attrs:{id:"process-nexttick"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#process-nexttick"}},[t._v("#")]),t._v(" process.nextTick()")]),t._v(" "),e("p",[t._v("它是在本轮循环执行的，而且是所有异步任务里面最快执行的，Node 执行完所有同步任务，接下来就会执行 process.nextTick 的任务队列。\n基本上，如果你希望异步任务尽可能快地执行，那就使用 process.nextTick。")]),t._v(" "),e("h2",{attrs:{id:"微任务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#微任务"}},[t._v("#")]),t._v(" 微任务")]),t._v(" "),e("p",[t._v('根据语言规格，Promise 对象的回调函数，会进入异步任务里面的"微任务"（microtask）队列。\n微任务队列追加在 process.nextTick 队列的后面，也属于本轮循环。')]),t._v(" "),e("blockquote",[e("p",[t._v("注意，只有前一个队列全部清空以后，才会执行下一个队列。")])]),t._v(" "),e("p",[t._v("至此任务执行顺序：")]),t._v(" "),e("ul",[e("li",[t._v("同步任务")]),t._v(" "),e("li",[t._v("process.nextTick()")]),t._v(" "),e("li",[t._v("微任务")])]),t._v(" "),e("h2",{attrs:{id:"事件循环的概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件循环的概念"}},[t._v("#")]),t._v(" 事件循环的概念")]),t._v(" "),e("p",[t._v("首先，有些人以为，除了主线程，还存在一个单独的事件循环线程。不是这样的，只有一个主线程，事件循环是在主线程上完成的。\n其次，Node 开始执行脚本时，会先进行事件循环的初始化，但是这时事件循环还没有开始，会先完成下面的事情。")]),t._v(" "),e("ul",[e("li",[t._v("同步任务")]),t._v(" "),e("li",[t._v("发出异步请求")]),t._v(" "),e("li",[t._v("规划定时器生效的时间")]),t._v(" "),e("li",[t._v("执行 process.nextTick() 等等")])]),t._v(" "),e("p",[t._v("最后，上面这些事情都干完了，事件循环就正式开始了。")]),t._v(" "),e("h2",{attrs:{id:"事件循环的六个阶段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件循环的六个阶段"}},[t._v("#")]),t._v(" 事件循环的六个阶段")]),t._v(" "),e("p",[t._v("如图：")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("   ┌───────────────────────┐\n┌─"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("│        timers         │"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("————— 执行 "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("setTimeout")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("、setInterval")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" 的回调\n│  └──────────┬────────────┘\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("             "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v(" 执行所有 Next Tick Queue 以及 MicroTask Queue 的回调\n│  ┌──────────┴────────────┐\n│  │     pending callbacks │"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("————— 执行由上一个 Tick 延迟下来的 "),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("I")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("O")]),t._v(" 回调（待完善，可忽略）\n│  └──────────┬────────────┘\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("             "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v(" 执行所有 Next Tick Queue 以及 MicroTask Queue 的回调\n│  ┌──────────┴────────────┐\n│  │     idle"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" prepare     │"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("————— 内部调用（可忽略）\n│  └──────────┬────────────┘\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("             "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v(" 执行所有 Next Tick Queue 以及 MicroTask Queue 的回调\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("             "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("                   ┌───────────────┐\n│  ┌──────────┴────────────┐      │   incoming"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("   │ "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("执行几乎所有的回调，除了 close callbacks、timers、setImmediate"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n│  │         poll          │"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("─────┤  connections"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" │\n│  └──────────┬────────────┘      │   data"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" etc"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("  │\n│             "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("                   "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("               "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("             "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("                   └───────────────┘\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("             "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v(" 执行所有 Next Tick Queue 以及 MicroTask Queue 的回调\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("  ┌──────────┴────────────┐\n│  │        check          │"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("————— "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("setImmediate")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" 的回调将会在这个阶段执行\n│  └──────────┬────────────┘\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("             "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v(" 执行所有 Next Tick Queue 以及 MicroTask Queue 的回调\n│  ┌──────────┴────────────┐\n└──┤    close callbacks    │"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("————— socket"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("on")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'close'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n   └───────────────────────┘s\n")])])]),e("p",[t._v("每个阶段都有一个先进先出的回调函数队列。只有一个阶段的回调函数队列清空了，该执行的回调函数都执行了，事件循环才会进入下一个阶段。")]),t._v(" "),e("ul",[e("li",[t._v("timers 阶段: 执行 setTimeout(callback) and setInterval(callback)预定的 callback;")]),t._v(" "),e("li",[t._v("I/O callbacks 阶段: 执行除了定时器、setImmediate 及 close callbacks 的回调;")]),t._v(" "),e("li",[t._v("idle, prepare 阶段: 仅 node 内部 libuv 库使用;")]),t._v(" "),e("li",[t._v("poll 阶段: poll 阶段很重要，这一阶段中，系统会做两件事情:\n"),e("ol",[e("li",[t._v("执行到点的定时器")]),t._v(" "),e("li",[t._v("执行 poll 队列中的事件\n"),e("ul",[e("li",[t._v("如果有别的定时器需要被执行，会回到 timer 阶段执行回调。")]),t._v(" "),e("li",[t._v("如果 poll 中没有定时器的情况下，会发现以下两件事情:\n"),e("ol",[e("li",[t._v("如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制")]),t._v(" "),e("li",[t._v("如果 poll 队列为空，会有两件事发生:\n"),e("ul",[e("li",[t._v("如果有 setImmediate 需要执行，poll 阶段会停止并且进入到 check 阶段执行 setImmediate")]),t._v(" "),e("li",[t._v("如果没有 setImmediate 需要执行，会等待回调被加入到队列中并立即执行回调")])])])])])])])])]),t._v(" "),e("li",[t._v("check 阶段: 执行 setImmediate() 设定的 callbacks;")]),t._v(" "),e("li",[t._v("close callbacks 阶段: 执行 close 事件，比如 socket.on(‘close’, callback)的 callback 会在这个阶段执行。")])]),t._v(" "),e("h2",{attrs:{id:"settimeout-和-setimmediate"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#settimeout-和-setimmediate"}},[t._v("#")]),t._v(" setTimeout 和 setImmediate")]),t._v(" "),e("p",[t._v("由于 setTimeout 在 timers 阶段执行，而 setImmediate 在 check 阶段执行。所以，setTimeout 会早于 setImmediate 完成。\n但是，因为 setTimeout 的第二个参数默认为 0。实际上，Node 做不到 0 毫秒，最少也需要 1 毫秒，第二个参数的取值范围在 1 毫秒到 2147483647 毫秒之间。也就是说，setTimeout(f, 0)等同于 setTimeout(f, 1)。")]),t._v(" "),e("p",[t._v("实际执行的时候，进入事件循环以后，有可能到了 1 毫秒，也可能还没到 1 毫秒，取决于系统当时的状况。如果没到 1 毫秒，那么 timers 阶段就会跳过，进入 check 阶段，先执行 setImmediate 的回调函数。")]),t._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("ul",[e("li",[t._v("同步任务总是比异步任务更早执行")]),t._v(" "),e("li",[t._v("本轮循环一定早于次轮循环执行，process.nextTick 和 Promise 的回调函数，追加在本轮循环，而 setTimeout、setInterval、setImmediate 的回调函数，追加在次轮循环")]),t._v(" "),e("li",[t._v("process.nextTick 是在本轮循环执行的，而且是所有异步任务里面最快执行的")]),t._v(" "),e("li",[t._v('Promise 对象的回调函数，会进入异步任务里面的 "微任务" 队列，微任务队列追加在 process.nextTick 队列的后面，也属于本轮循环')]),t._v(" "),e("li",[t._v("process.nextTick()于 setImmediate()的区别：\n"),e("ol",[e("li",[t._v('多个 process.nextTick() 语句总是在当前"执行栈"一次执行完。')]),t._v(" "),e("li",[t._v("多个 setImmediate() 可能则需要多次 loop 才能执行完。")])])])])])}),[],!1,null,null,null);s.default=r.exports}}]);