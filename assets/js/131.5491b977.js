(window.webpackJsonp=window.webpackJsonp||[]).push([[131],{561:function(t,e,r){"use strict";r.r(e);var a=r(55),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"页面渲染过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#页面渲染过程"}},[t._v("#")]),t._v(" 页面渲染过程")]),t._v(" "),r("h2",{attrs:{id:"浏览器渲染机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染机制"}},[t._v("#")]),t._v(" 浏览器渲染机制")]),t._v(" "),r("ul",[r("li",[t._v("字节 → 字符 → 令牌 → 节点 → 对象模型")]),t._v(" "),r("li",[t._v("浏览器会将 HTML 解析成一个 DOM 树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点")]),t._v(" "),r("li",[t._v("将 CSS 解析成 CSS Rule Tree")]),t._v(" "),r("li",[t._v("根据 DOM 树和 CSSOM 来构造 Rendering Tree。注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像 Header 或 display:none 的东西就没必要放在渲染树中了")]),t._v(" "),r("li",[t._v("有了 Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的 CSS 定义以及他们的从属关系。下一步操作称之为 layout，顾名思义就是计算出每个节点在屏幕中的位置")]),t._v(" "),r("li",[t._v("再下一步就是绘制，即遍历 render 树，并使用 UI 后端层绘制每个节点。")])]),t._v(" "),r("h2",{attrs:{id:"主流浏览器渲染流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#主流浏览器渲染流程"}},[t._v("#")]),t._v(" 主流浏览器渲染流程")]),t._v(" "),r("h2",{attrs:{id:"webkit"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#webkit"}},[t._v("#")]),t._v(" webkit")]),t._v(" "),r("p",[r("img",{attrs:{src:"http://taligarsiel.com/Projects/webkitflow.png",alt:"imgs"}})]),t._v(" "),r("h2",{attrs:{id:"geoko-firefox"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#geoko-firefox"}},[t._v("#")]),t._v(" Geoko(firefox)")]),t._v(" "),r("p",[r("img",{attrs:{src:"http://taligarsiel.com/Projects/webkitflow.png",alt:"imgs"}})])])}),[],!1,null,null,null);e.default=s.exports}}]);