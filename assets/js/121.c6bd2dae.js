(window.webpackJsonp=window.webpackJsonp||[]).push([[121],{551:function(t,e,a){"use strict";a.r(e);var r=a(55),n=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"vue-小知识点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-小知识点"}},[t._v("#")]),t._v(" Vue 小知识点")]),t._v(" "),a("h2",{attrs:{id:"vue-的双向绑定的原理，和-angular-的对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-的双向绑定的原理，和-angular-的对比"}},[t._v("#")]),t._v(" vue 的双向绑定的原理，和 angular 的对比")]),t._v(" "),a("p",[t._v("在不同的 MVVM 框架中，实现双向数据绑定的技术有所不同。")]),t._v(" "),a("p",[t._v("AngularJS 采用“脏值检测”的方式，数据发生变更后，对于所有的数据和视图的绑定关系进行一次检测，识别是否有数据发生了改变，有变化进行处理，可能进一步引发其他数据的改变，所以这个过程可能会循环几次，一直到不再有数据变化发生后，将变更的数据发送到视图，更新页面展现。如果是手动对 ViewModel 的数据进行变更，为确保变更同步到视图，需要手动触发一次“脏值检测”。")]),t._v(" "),a("p",[t._v("VueJS 则使用 ES5 提供的 Object.defineProperty() 方法，监控对数据的操作，从而可以自动触发数据同步。并且，由于是在不同的数据上触发同步，可以精确的将变更发送给绑定的视图，而不是对所有的数据都执行一次检测。")]),t._v(" "),a("h2",{attrs:{id:"created-与-mounted-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#created-与-mounted-的区别"}},[t._v("#")]),t._v(" created 与 mounted 的区别")]),t._v(" "),a("ul",[a("li",[t._v("created:在模板渲染成 html 前调用，即通常初始化某些属性值，然后再渲染成视图。")]),t._v(" "),a("li",[t._v("mounted:在模板渲染成 html 后调用，通常是初始化页面完成后，再对 html 的 dom 节点进行一些需要的操作。\n其")])])])}),[],!1,null,null,null);e.default=n.exports}}]);